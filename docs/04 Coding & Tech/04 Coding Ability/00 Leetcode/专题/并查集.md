---
title: 并查集
date: 2025-04-30
article: false
tag:
---

## 什么是并查集
### 朋友圈的表示方式
想象一个班级里的学生，随着时间的推移，学生们形成了不同的朋友圈。并查集就是用来跟踪这些朋友圈的工具。

每个朋友圈有一个 " 代表 "（老大）。如果我想知道两个学生是否在同一个朋友圈，只需要看他们的 " 老大 " 是否是同一个人。

### 初始化

开始时，每个学生独自形成一个朋友圈，自己是自己的老大。

```python
# 初始化：每个人是自己的老大
def init(n):
    parent = [i for i in range(n)]
    return parent
```

### Find 操作：查找老大

```python
# 查找某人的老大
def find(parent, x):
    if parent[x] != x:
        parent[x] = find(parent, parent[x])  # 路径压缩
    return parent[x]
```

### Union 操作：合并朋友圈

```python
# 合并两个朋友圈
def union(parent, x, y):
    root_x = find(parent, x)
    root_y = find(parent, y)
    if root_x != root_y:
        parent[root_y] = root_x  # y的老大认x的老大为新老大
```

**<font color="#fbd5b5">路径压缩</font>**
当我们查找某人的老大时，顺便更新路径上每个人的老大，使得下次查找更快
<font color="#c00000">按秩合并</font>
让小朋友圈并入大朋友圈，而不是反过来
### 应用场景

网络连通性：判断网络中的计算机是否连通
环检测：判断图中是否有环
迷宫生成：生成迷宫的随机算法
最小生成树：Kruskal算法的核心部分

### 完整示例

```python
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n  # 用于按秩合并

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # 路径压缩
        return self.parent[x]

    def union(self, x, y):
        root_x = self.find(x)
        root_y = self.find(y)

        if root_x == root_y:
            return

        # 按秩合并
        if self.rank[root_x] < self.rank[root_y]:
            self.parent[root_x] = root_y
        elif self.rank[root_x] > self.rank[root_y]:
            self.parent[root_y] = root_x
        else:
            self.parent[root_y] = root_x
            self.rank[root_x] += 1
```

## Leetcode
### 基础题目
1. **[547. 省份数量](https://leetcode.com/problems/number-of-provinces/)** - 经典的并查集入门题
2. **[200. 岛屿数量](https://leetcode.com/problems/number-of-islands/)** - 可以用 DFS/BFS 或并查集解决
3. **[128. 最长连续序列](https://leetcode.com/problems/longest-consecutive-sequence/)** - 可用并查集优化
4. **[990. 等式方程的可满足性](https://leetcode.com/problems/satisfiability-of-equality-equations/)**

### 中等题目
5. **[721. 账户合并](https://leetcode.com/problems/accounts-merge/)** - 实际应用场景
6. **[684. 冗余连接](https://leetcode.com/problems/redundant-connection/)** - 在图中寻找环
7. **[1319. 连通网络的操作次数](https://leetcode.com/problems/number-of-operations-to-make-network-connected/)**
8. **[959. 由斜杠划分区域](https://leetcode.com/problems/regions-cut-by-slashes/)**
9. **[685. 冗余连接 II](https://leetcode.com/problems/redundant-connection-ii/)** - 有向图版本
10. **[1202. 交换字符串中的元素](https://leetcode.com/problems/smallest-string-with-swaps/)**

### 进阶题目
11. **[765. 情侣牵手](https://leetcode.com/problems/couples-holding-hands/)**
12. **[952. 按公因数计算最大组件大小](https://leetcode.com/problems/largest-component-size-by-common-factor/)**
13. **[803. 打砖块](https://leetcode.com/problems/bricks-falling-when-hit/)** - 需要逆向思维
14. **[1632. 矩阵转换后的秩](https://leetcode.com/problems/rank-transform-of-a-matrix/)** - 结合排序和并查集
15. **[778. 水位上升的泳池中游泳](https://leetcode.com/problems/swim-in-rising-water/)** - 结合二分查找