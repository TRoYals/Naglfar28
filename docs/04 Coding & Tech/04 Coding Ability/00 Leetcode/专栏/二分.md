---
title: äºŒåˆ†
date: 2024-05-07
article: false
tag:

---

### [540. æœ‰åºæ•°ç»„ä¸­çš„å•ä¸€å…ƒç´  - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/single-element-in-a-sorted-array/description/)  
  
ç”¨ [ä½è¿ç®—](ä½è¿ç®—) ç§’äº†, å†ä¹Ÿä¸è¯´ä½è¿ç®—æ²¡ç”¨äº†,ä½†è¿™ç« çš„ä¸»é¢˜æ˜¯äºŒåˆ†,æ‰€ä»¥è¿˜æ˜¯å‡†å¤‡ç”¨äºŒåˆ†åš
```python
class Solution:
    def singleNonDuplicate(self, nums: List[int]) -> int:
        curr = 0
        for i in range(len(nums)):
            curr = curr[i]
        return curr
```
ä¸€ä¸ªäºŒåˆ†æ³•çš„ç­”æ¡ˆ
```python
class Solution:
    def singleNonDuplicate(self, nums: List[int]) -> int:
        l,r = 0,len(nums)-1
        if (len(nums)==1):
            return nums[0]
        while(l<=r):
            mid = (l+r)//2
            if(mid==0 and nums[mid+1]!=nums[mid]):
                return nums[mid]
            if(mid==len(nums)-1 and nums[len(nums)-2]!=nums[mid]):
                return nums[mid]
            if(nums[mid]!=nums[mid-1]and nums[mid]!=nums[mid+1]):
                return nums[mid]
            if(nums[mid+1]==nums[mid]):
                if((r+1-mid)%2==0):
                    r=mid-1
                else:
                    l = mid 
            if(nums[mid-1]==nums[mid]):
                if((r-mid)%2==0):
                    r = mid
                else:
                    l = mid+1
        return -1
```
æ³¨æ„æ¨¡æ¿  
è¿™é‡Œçš„ return æ¡ä»¶éœ€è¦è€ƒè™‘åˆ°è¾¹ç•Œé—®é¢˜
```python
def binarySearch(nums, target):
	# å·¦å³éƒ½é—­åˆçš„åŒºé—´ [l, r]
	# A closed interval [l, r] with both ends inclusive.
	l, r = 0, len(nums) - 1
	while l <= r:
		mid = (left + right) >> 1
		if nums[mid] == target: return mid
		# æœç´¢åŒºé—´å˜ä¸º [mid+1, right]
		# Narrow down the search range to [mid+1, right]
		if nums[mid] < target: l = mid + 1
		# æœç´¢åŒºé—´å˜ä¸º [left, mid - 1]
		# Narrow down the search range to [left, mid - 1]
		if nums[mid] > target: r = mid - 1
	return -1
```


### [34. åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½® - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/)  
  
æ¨¡æ¿ç§’æ€é¢˜, æ— éš¾ç‚¹
```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        l, r = 0, len(nums) - 1
        if target not in nums:
            return [-1, -1]
        while l <= r:
            mid = (l + r) // 2
            if nums[mid] == target:
                l_ptr = mid
                r_ptr = mid
                while l_ptr - 1 >= 0 and nums[l_ptr - 1] == target:
                    l_ptr -= 1
                while r_ptr + 1 < len(nums) and nums[r_ptr + 1] == target:
                    r_ptr += 1
                return [l_ptr, r_ptr]
            if nums[mid] > target:
                r = mid - 1
            if nums[mid] < target:
                l = mid + 1
        return -1
```
ä¸éš¾å‘ç°, ä¸­é—´ç”¨ while å–å·§äº†, è‚¯å®šä¸èƒ½è¿™æ ·!  
è€è€å®å®å†™äº†ä¸¤ä¸ª
```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        def findFirst(nums, target):
            l, r = 0, len(nums) - 1
            while l <= r:
                mid = (l + r) // 2
                if nums[mid] >= target:
                    r = mid - 1
                else:
                    l = mid + 1
            if l < len(nums) and nums[l] == target:
                return l
            return -1
        def findLast(nums, target):
            l, r = 0, len(nums) - 1
            while l <= r:
                mid = (l + r) // 2
                if nums[mid] <= target:
                    l = mid + 1
                else:
                    r = mid - 1
            if r >= 0 and nums[r] == target:
                return r
            return -1
        left = findFirst(nums, target)
        right = findLast(nums, target)
        return [left, right]
```


### [278. ç¬¬ä¸€ä¸ªé”™è¯¯çš„ç‰ˆæœ¬ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/first-bad-version/description/)  
  
è¿™é“ç®€å•é¢˜,åšçš„æ—¶å€™å´å‡ºç°äº†é—®é¢˜  
é‡ç‚¹æ˜¯  
`l= mid+1` å’Œ `r=mid` çš„æ¡ä»¶ä¸ºä»€ä¹ˆæ˜¯è¿™æ ·?  
`[0,0,0,0,0,0,1,1]` å…¶å®æ˜¯è¿™ä¸ªæ ·çš„é¢˜, è¦æ±‚è¿”å›ç¬¬ä¸€ä¸ª 1 çš„ä½ç½®,æ‰€ä»¥å³è¾¹è‚¯å®šæ˜¯ä¸å˜çš„, åªç”¨å¾€å·¦è¾¹é ,  
åŒç†å¦‚æœè¦æ±‚è¿”å›æœ€åä¸€ä¸ª 0,å°±ä¼šå˜æˆ `l=mid, r = mid-1` è¿™æ ·çš„æ¡ä»¶
```python
class Solution:
    def firstBadVersion(self, n: int) -> int:
        if n == 1:
            return 1
        l, r = 1, n
        while l <= r:
            mid = (l + r) // 2
            if l == r:
                return mid
            if isBadVersion(mid) == False:
                l = mid + 1
            if isBadVersion(mid) == True:
                r = mid
        return -1
```
ä¸æ˜¯,é˜¿ sir, ä½ è¿™å†™çš„ä¸ªå•¥,ç»™æˆ‘çœ‹ç¬‘äº†, çœ‹çœ‹æ­£ç¡®ç­”æ¡ˆæŠŠ,çœ‹çœ‹ä½ çš„é€»è¾‘ä¸Šçš„ç–å¿½, æ˜æ˜¾ä¸‹é¢é‚£ä¸ªå½¢å¼æ›´å¥½ä¸æ˜¯å— (å› ä¸ºè€ƒè™‘äº†é€€å‡ºå¾ªç¯çš„æ—¶æœº)
```python
class Solution:
    def firstBadVersion(self, n: int) -> int:
        l, r = 1, n
        while l <= r:
            mid = (l + r) // 2
            if isBadVersion(mid) == True:
                r = mid - 1
            else:
                l = mid + 1
        return l
```


### [69. x çš„å¹³æ–¹æ ¹ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/sqrtx/description/)
  
ä¸€ä¸ªåŒæ ·çš„é¢˜,æ³¨æ„æ¨¡æ¿, è¿™é‡Œä¸ºä»€ä¹ˆè¦å…ˆåˆ¤æ–­ `==`, å¯ä»¥ç†è§£ä¸º `[0,0,0,0,1]` æ¨¡å‹è¿”å›æœ€åä¸€ä¸ª `0`(å› ä¸ºå­˜åœ¨ä½™æ•°), è€Œå½“æ²¡æœ‰ä½™æ•°, åˆšå¥½ç›¸ä¹˜ç­‰æ—¶,éœ€è¦è¿”å›é‚£ä¸ª `1`
```python
class Solution:
    def mySqrt(self, x: int) -> int:
        l, r = 0, x
        while l <= r:
            mid = (l + r) // 2
            if mid * mid == x:
                return mid
            if mid * mid > x:
                r = mid - 1
            else:
                l = mid + 1
        return r
```


### [378. æœ‰åºçŸ©é˜µä¸­ç¬¬ K å°çš„å…ƒç´  - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/description/)
  
æ²¡æœ‰ç”¨åˆ°çŸ©é˜µçš„æ€§è´¨, ç¬¬ä¸€ä¸ªå¯ä»¥ä¼˜åŒ–, ä½†ä¸é‡è¦äº†  
æœ‰ä¸ªé—®é¢˜,å†™çš„æ—¶å€™æ²¡æœ‰æƒ³æ˜ç™½, å°±æ˜¯ `is_satisfied(mid)<k` çš„è¿™ä¸ªæ›´æ–°æ¡ä»¶, ä¹‹å‰å†™çš„æ—¶å€™ç”¨çš„æ˜¯ `is_satisfied<=k` çš„è¿™ä¸ªæ¡ä»¶, ç„¶åè¿”å›çš„ç»“æœé‡Œå°±ä¼šæœ‰ä¸åœ¨æ•°ç»„ä¸­çš„æ•°, è¯´æ˜è¿™ä¸ªåœ°æ–¹è¿˜æ˜¯æ²¡æœ‰æƒ³æ¸…æ¥š,ä¸æ˜¯ä¸è¡Œ,æ˜¯å¦‚æœç”¨åŸæ¥çš„æ¡ä»¶å°±éœ€è¦å¤šåŠ ä¸ªåˆ¤æ–­.  
é‚£ä¹ˆä¸ºä»€ä¹ˆå‘¢?
::: info
å…³äº `is_satisfied(mid) < k` ä¸ `is_satisfied(mid) <= k`
- **`is_satisfied(mid) < k`**: æ­¤æ¡ä»¶æ£€æŸ¥åœ¨çŸ©é˜µä¸­å°äºæˆ–ç­‰äº midmid çš„å…ƒç´ æ•°é‡æ˜¯å¦å°‘äº ğ‘˜ã€‚å¦‚æœæ˜¯ï¼Œè¯´æ˜ç¬¬ ğ‘˜ å°çš„å…ƒç´ å¿…é¡»æ¯” mid å¤§ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦è°ƒæ•´äºŒåˆ†æœç´¢çš„ä¸‹ç•Œ ğ‘™ã€‚æ­¤é€»è¾‘ç”¨äºç¡®ä¿æˆ‘ä»¬ä¸ä¼šé”™è¿‡ç¬¬ ğ‘˜ å°çš„å…ƒç´ ã€‚
- **`is_satisfied(mid) <= k`**: å¦‚æœä½ åŸæ¥ä½¿ç”¨çš„æ˜¯è¿™ä¸ªæ¡ä»¶ï¼Œå®é™…ä¸Šå®ƒä¼šåœ¨æ‰¾åˆ°æ°å¥½æœ‰ ğ‘˜ ä¸ªå…ƒç´ å°äºæˆ–ç­‰äº mid çš„æƒ…å†µä¸‹åœæ­¢ï¼Œä½†è¿™å¹¶ä¸ä¿è¯ mid æ˜¯ç¬¬ ğ‘˜å°çš„å…ƒç´ ï¼Œç‰¹åˆ«æ˜¯åœ¨å­˜åœ¨é‡å¤å…ƒç´ çš„æƒ…å†µä¸‹ã€‚å®ƒå¯èƒ½ä¼šå¯¼è‡´äºŒåˆ†æŸ¥æ‰¾è¿‡æ—©åœ°åœæ­¢ï¼Œè€Œé”™è¿‡å®é™…çš„ç¬¬ ğ‘˜ å°å…ƒç´ ã€‚
:::
ç®€å•æ¥è¯´å°±æ˜¯ `is_satisfied` é‡Œçš„ `<=` åˆ¤æ–­å·²ç»è€ƒè™‘äº†é‡å¤æ•°çš„æƒ…å†µäº†,  
```python
class Solution:
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        def is_satisfied(num):
            # given a guess num, return if satisfied
            count = 0
            for i in range(len(matrix)):
                for j in range(len(matrix[0])):
                    if matrix[i][j] <= num:
                        count += 1
            return count
        l, r = matrix[0][0], matrix[len(matrix) - 1][len(matrix) - 1]
        while l <= r:
            mid = (l + r) // 2
            if is_satisfied(mid) < k:
                l = mid + 1
            else:
                r = mid - 1
        return l
```


### [475. ä¾›æš–å™¨ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/heaters/description/)  
  
å¯¹äºæ¯ä¸ªæˆ¿å±‹ï¼Œè¦ä¹ˆç”¨å‰é¢çš„æš–æ°”ï¼Œè¦ä¹ˆç”¨åé¢çš„ï¼ŒäºŒè€…å–è¿‘çš„ï¼Œå¾—åˆ°è·ç¦»  
å¾ˆæœ‰æƒ³æ³•çš„ä¸€é¢˜, å»ºè®®å¤šåšå¤šæ€è€ƒ
```python
class Solution:
    def findRadius(self, houses: List[int], heaters: List[int]) -> int:
        houses.sort()
        heaters.sort()
        max_length = 0
        for i in range(len(houses)):
            insert_num = bisect.bisect_left(heaters, houses[i], 0, len(heaters))
            if insert_num == 0:
                max_length = max(max_length, heaters[0] - houses[i])
            elif insert_num == len(heaters):
                max_length = max(max_length, houses[i] - heaters[len(heaters) - 1])
            else:
                max_length = max(
                    max_length,
                    min(
                        houses[i] - heaters[insert_num - 1],
                        heaters[insert_num] - houses[i],
                    ),
                )
        return max_length
```
æ‹¿ JS åšäº†,æ³¨æ„æ’åºè¦è¿™ä¹ˆæ’  
`houses.sort((a,b)=>a-b)`  
ç”¨äºŒåˆ†çš„æ—¶å€™ï¼Œå¤šä¸€ä¸ªæ€è€ƒæ–¹å¼ï¼š  
å°±æ˜¯æ’å…¥**åˆ°å“ªé‡Œ**ï¼Œ
```typescript
function bisectLeft(house:number,heater:number[]){
    let left = 0;
    let right = heater.length;
    let mid = Math.floor((left+right)/2); 
    while(left<right){
        mid = Math.floor((left+right)/2);
        if(heater[mid]>=house){
            right = mid;
        }else{
            left = mid+1;
        }
    }
    return right;
}
```


### [875. çˆ±åƒé¦™è•‰çš„ç‚ç‚ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/koko-eating-bananas/description/)
 
```python
class Solution:
    def minEatingSpeed(self, piles: List[int], h: int) -> int:
        def possible(k):
            count = 0
            for i in range(len(piles)):
                count += piles[i] // k if (piles[i] % k == 0) else piles[i] // k + 1
                if count > h:
                    return False
            return True
        l, r = 1, max(piles)
        while l <= r:
            mid = (l + r) // 2
            if possible(mid) is False:
                l = mid + 1
            else:
                r = mid - 1
        return l
```


### [778. æ°´ä½ä¸Šå‡çš„æ³³æ± ä¸­æ¸¸æ³³ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/swim-in-rising-water/description/)  
äºŒåˆ†è¿˜æ˜¯å¸…çš„, ä½†æ˜¯ å¥½åƒ [ä¼˜å…ˆé˜Ÿåˆ—](å †) ä¹Ÿå¯ä»¥åš, æœ‰æ€è·¯å—?  

```python
class Solution:
    def swimInWater(self, grid: List[List[int]]) -> int:
        def find_max(array):
            max_value = 0
            for row in array:
                for element in row:
                    if element > max_value:
                        max_value = element
            return max_value
        def dfs(x, y, cur_max):
            nonlocal is_found
            if is_found:
                return
            if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]):
                return
            if visited[x][y] == 1:
                return
            if grid[x][y] > cur_max:
                return
            if x == len(grid) - 1 and y == len(grid[0]) - 1:
                is_found = True
                return
            visited[x][y] = 1
            dfs(x - 1, y, cur_max)
            dfs(x + 1, y, cur_max)
            dfs(x, y + 1, cur_max)
            dfs(x, y - 1, cur_max)
            return
        l = 0
        r = find_max(grid)
        while l <= r:
            visited = [[0] * len(grid) for _ in range(len(grid[0]))]
            mid = (l + r) // 2
            is_found = False
            dfs(0, 0, mid)
            if is_found:
                r = mid - 1
            else:
                l = mid + 1
        return l
```

