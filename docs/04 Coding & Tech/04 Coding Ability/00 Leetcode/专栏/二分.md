---
title: 二分
date: 2024-05-07
article: false
tag:
cards-deck: 04 Coding & Tech::04 Coding Ability::00 Leetcode::专栏
---

### [540. 有序数组中的单一元素 - 力扣（LeetCode）](https://leetcode.cn/problems/single-element-in-a-sorted-array/description/)  
  
用 [位运算](位运算) 秒了, 再也不说位运算没用了,但这章的主题是二分,所以还是准备用二分做
```python
class Solution:
    def singleNonDuplicate(self, nums: List[int]) -> int:
        curr = 0
        for i in range(len(nums)):
            curr = curr[i]
        return curr
```
一个二分法的答案
```python
class Solution:
    def singleNonDuplicate(self, nums: List[int]) -> int:
        l,r = 0,len(nums)-1
        if (len(nums)==1):
            return nums[0]
        while(l<=r):
            mid = (l+r)//2
            if(mid==0 and nums[mid+1]!=nums[mid]):
                return nums[mid]
            if(mid==len(nums)-1 and nums[len(nums)-2]!=nums[mid]):
                return nums[mid]
            if(nums[mid]!=nums[mid-1]and nums[mid]!=nums[mid+1]):
                return nums[mid]
            if(nums[mid+1]==nums[mid]):
                if((r+1-mid)%2==0):
                    r=mid-1
                else:
                    l = mid 
            if(nums[mid-1]==nums[mid]):
                if((r-mid)%2==0):
                    r = mid
                else:
                    l = mid+1
        return -1
```
注意模板  
这里的 return 条件需要考虑到边界问题
```python
def binarySearch(nums, target):
	# 左右都闭合的区间 [l, r]
	# A closed interval [l, r] with both ends inclusive.
	l, r = 0, len(nums) - 1
	while l <= r:
		mid = (left + right) >> 1
		if nums[mid] == target: return mid
		# 搜索区间变为 [mid+1, right]
		# Narrow down the search range to [mid+1, right]
		if nums[mid] < target: l = mid + 1
		# 搜索区间变为 [left, mid - 1]
		# Narrow down the search range to [left, mid - 1]
		if nums[mid] > target: r = mid - 1
	return -1
```


### [34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/)  
  
模板秒杀题, 无难点
```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        l, r = 0, len(nums) - 1
        if target not in nums:
            return [-1, -1]
        while l <= r:
            mid = (l + r) // 2
            if nums[mid] == target:
                l_ptr = mid
                r_ptr = mid
                while l_ptr - 1 >= 0 and nums[l_ptr - 1] == target:
                    l_ptr -= 1
                while r_ptr + 1 < len(nums) and nums[r_ptr + 1] == target:
                    r_ptr += 1
                return [l_ptr, r_ptr]
            if nums[mid] > target:
                r = mid - 1
            if nums[mid] < target:
                l = mid + 1
        return -1
```
不难发现, 中间用 while 取巧了, 肯定不能这样!  
老老实实写了两个
```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        def findFirst(nums, target):
            l, r = 0, len(nums) - 1
            while l <= r:
                mid = (l + r) // 2
                if nums[mid] >= target:
                    r = mid - 1
                else:
                    l = mid + 1
            if l < len(nums) and nums[l] == target:
                return l
            return -1
        def findLast(nums, target):
            l, r = 0, len(nums) - 1
            while l <= r:
                mid = (l + r) // 2
                if nums[mid] <= target:
                    l = mid + 1
                else:
                    r = mid - 1
            if r >= 0 and nums[r] == target:
                return r
            return -1
        left = findFirst(nums, target)
        right = findLast(nums, target)
        return [left, right]
```


### [278. 第一个错误的版本 - 力扣（LeetCode）](https://leetcode.cn/problems/first-bad-version/description/)  
  
这道简单题,做的时候却出现了问题  
重点是  
`l= mid+1` 和 `r=mid` 的条件为什么是这样?  
`[0,0,0,0,0,0,1,1]` 其实是这个样的题, 要求返回第一个 1 的位置,所以右边肯定是不变的, 只用往左边靠,  
同理如果要求返回最后一个 0,就会变成 `l=mid, r = mid-1` 这样的条件
```python
class Solution:
    def firstBadVersion(self, n: int) -> int:
        if n == 1:
            return 1
        l, r = 1, n
        while l <= r:
            mid = (l + r) // 2
            if l == r:
                return mid
            if isBadVersion(mid) == False:
                l = mid + 1
            if isBadVersion(mid) == True:
                r = mid
        return -1
```
不是,阿 sir, 你这写的个啥,给我看笑了, 看看正确答案把,看看你的逻辑上的疏忽, 明显下面那个形式更好不是吗 (因为考虑了退出循环的时机)
```python
class Solution:
    def firstBadVersion(self, n: int) -> int:
        l, r = 1, n
        while l <= r:
            mid = (l + r) // 2
            if isBadVersion(mid) == True:
                r = mid - 1
            else:
                l = mid + 1
        return l
```


### [69. x 的平方根 - 力扣（LeetCode）](https://leetcode.cn/problems/sqrtx/description/)
  
一个同样的题,注意模板, 这里为什么要先判断 `==`, 可以理解为 `[0,0,0,0,1]` 模型返回最后一个 `0`(因为存在余数), 而当没有余数, 刚好相乘等时,需要返回那个 `1`
```python
class Solution:
    def mySqrt(self, x: int) -> int:
        l, r = 0, x
        while l <= r:
            mid = (l + r) // 2
            if mid * mid == x:
                return mid
            if mid * mid > x:
                r = mid - 1
            else:
                l = mid + 1
        return r
```

