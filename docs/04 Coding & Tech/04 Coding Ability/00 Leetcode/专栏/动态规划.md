---
title: 动态规划
date: 2024-05-04
article: false
tag:
cards-deck: 04 Coding & Tech::04 Coding Ability::00 Leetcode::专栏
---

### [1235. 规划兼职工作 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-profit-in-job-scheduling/description/)
  
  
这题主要是要考虑到用 `sorted`+`zip` 方法按照 endTime 先排序  
一开始的思路
```python
class Solution:
    def jobScheduling(
        self, startTime: List[int], endTime: List[int], profit: List[int]
    ) -> int:
        maxTime = max(endTime)
        curr = [0] * (maxTime + 1)
        jobs = sorted(zip(startTime, endTime, profit), key=lambda x: x[1])
        for p, j, k in jobs:
            pre = p
            pre_j = j
            while pre > 0 and curr[pre] == 0:
                pre -= 1
            curr[p] = curr[pre]
            while pre_j > 0 and curr[pre_j] == 0:
                pre_j -= 1
            curr[j] = curr[pre_j]
            if curr[p] + k > curr[j]:
                curr[j] = curr[p] + k
        return curr[-1]
```
然后被恶心到了, 艹,头一次见 *Memory Limit Exceeded*, 这就是 hard 的难度吗?  
![image.png](https://oss.naglfar28.com/naglfar28/202405042353084.png)  
一个更好的答案,其中有用到 [03 bisect模块](../../../01%20Programming%20Language/02%20Python/03%20python标准库/03%20bisect模块)
```python
import bisect
class Solution:
    def jobScheduling(
        self, startTime: List[int], endTime: List[int], profit: List[int]
    ) -> int:
        # 合并为一个列表
        jobs = sorted(zip(startTime, endTime, profit), key=lambda x: x[1])
        dp = [(0, 0)]  # (结束时间, 累积收益)
        for s, e, p in jobs:
            # 找到在当前作业之前结束的最后一个作业
            i = bisect.bisect_right(dp, (s, float('inf')))
            max_profit = dp[i - 1][1] + p
            # 只有当当前收益比之前的最大收益高时，才加入
            if max_profit > dp[-1][1]:
                dp.append((e, max_profit))
        return dp[-1][1]
```

