---
title: 滑动窗口
date: 2024-05-04
article: false
tag:
cards-deck: 04 Coding & Tech::04 Coding Ability::00 Leetcode::专栏
---

##
### [209. 长度最小的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-size-subarray-sum/description/)
  
这里简单用滑动窗口, 这个窗口是*右 for 左 while*的.
```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        min_length = 10**6
        sum = 0
        left = 0
        for right in range(len(nums)):
            sum += nums[right]
            while sum >= target:
                min_length = (
                    (right - left + 1)
                    if (right - left + 1) < min_length
                    else min_length
                )
                sum -= nums[left]
                left += 1
        min_length = min_length if min_length != 10**6 else 0
        return min_length
```


### [76. 最小覆盖子串 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-window-substring/description/)
  
这题主要需要考虑的是 `t` 中出现重复字符的问题, 我的解决方法是做个字典, 来供删除,  
实际做起来还是比较清晰的, 就是窗口移动时的逻辑需要判断, 个人感觉可以一边写一边 print 不断调试
```python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        curr = self.constrcut_t(t)
        right = 0
        return_str = ""
        min_length = 10**5
        for i in range(len(s)):
            while not self.is_satisfied(curr) and right < len(s):
                if s[right] in curr:
                    curr[s[right]] -= 1
                right += 1
            if right - i < min_length and self.is_satisfied(curr):
                return_str = s[i:right]
                min_length = right - i
            if s[i] in curr:
                curr[s[i]] += 1
        return return_str

    def is_satisfied(self, curr: dict):
        for key, value in curr.items():
            if value >= 1:
                return False
        return True

    def constrcut_t(self, t):
        cur = {}
        for i in range(len(t)):

            if t[i] in cur:
                cur[t[i]] += 1
            else:
                cur[t[i]] = 1
        return cur
```

### [438. 找到字符串中所有字母异位词 - 力扣（LeetCode）](https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/)
  
这种题目还是要注意构造一个 dist 来记录存在过的字符, 只要考虑到滑动窗口就行了, 不要给自己上难度.
```python
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        right = 0
        curr = self.construct(p)
        return_list = []
        for left in range(len(s) - len(p) + 1):
            while right - left < len(p):
                if s[right] in curr:
                    curr[s[right]] -= 1
                    if self.is_satisfied(curr):
                        return_list.append(left)
                right += 1
            if s[left] in curr:
                curr[s[left]] += 1
        return return_list
    def is_satisfied(self, curr):
        for key, value in curr.items():
            if value != 0:
                return False
        return True
    def construct(self, p):
        dir = {}
        for i in range(len(p)):
            if p[i] in dir:
                dir[p[i]] += 1
            else:
                dir[p[i]] = 1
        return dir
```

## 同样的题目
[3. 无重复字符的最长子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/)
